import{a as m}from"./chunk-4BPNZXC3.mjs";import{a as B,b as A,c as G,d as T,e as R,f as M,g as F,i as Y,j,k as H,l as _,m as O}from"./chunk-AO5Q4NQQ.mjs";import{a as k}from"./chunk-U6LOUQAF.mjs";import"./chunk-J5J7XQ4F.mjs";import{a as q}from"./chunk-BOP2KBYH.mjs";import{a as S}from"./chunk-6XGRHI2A.mjs";import"./chunk-INOGIEW4.mjs";import"./chunk-TI4EEUUG.mjs";import{X as P,b as s}from"./chunk-DMXVZUOD.mjs";import"./chunk-BKDDFIKN.mjs";import"./chunk-YPUTD6PB.mjs";import"./chunk-6BY5RJGC.mjs";import{a as u}from"./chunk-GTKDMUJJ.mjs";var a=new Map,X=new Map,K=new Map,Q=u(()=>{X.clear(),K.clear(),a.clear()},"clear"),D=u((e,t)=>{let n=X.get(t)||[];return s.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),te=u((e,t)=>{let n=X.get(t)||[];return s.info("Descendants of ",t," is ",n),s.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||D(e.v,t)||D(e.w,t)||n.includes(e.w):(s.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),U=u((e,t,n,c)=>{s.warn("Copying children of ",e,"root",c,"data",t.node(e),c);let r=t.children(e)||[];e!==c&&r.push(e),s.warn("Copying (nodes) clusterId",e,"nodes",r),r.forEach(o=>{if(t.children(o).length>0)U(o,t,n,c);else{let d=t.node(o);s.info("cp ",o," to ",c," with parent ",e),n.setNode(o,d),c!==t.parent(o)&&(s.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==c&&o!==e?(s.debug("Setting parent",o,e),n.setParent(o,e)):(s.info("In copy ",e,"root",c,"data",t.node(e),c),s.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==c,"node!==clusterId",o!==e));let g=t.edges(o);s.debug("Copying Edges",g),g.forEach(l=>{s.info("Edge",l);let h=t.edge(l.v,l.w,l.name);s.info("Edge data",h,c);try{te(l,c)?(s.info("Copying as ",l.v,l.w,h,l.name),n.setEdge(l.v,l.w,h,l.name),s.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.info("Skipping copy of edge ",l.v,"-->",l.w," rootId: ",c," clusterId:",e)}catch(p){s.error(p)}})}s.debug("Removing node",o),t.removeNode(o)})},"copy"),V=u((e,t)=>{let n=t.children(e),c=[...n];for(let r of n)K.set(r,e),c=[...c,...V(r,t)];return c},"extractDescendants");var se=u((e,t,n)=>{let c=e.edges().filter(l=>l.v===t||l.w===t),r=e.edges().filter(l=>l.v===n||l.w===n),o=c.map(l=>({v:l.v===t?n:l.v,w:l.w===t?t:l.w})),d=r.map(l=>({v:l.v,w:l.w}));return o.filter(l=>d.some(h=>l.v===h.v&&l.w===h.w))},"findCommonEdges"),N=u((e,t,n)=>{let c=t.children(e);if(s.trace("Searching children of id ",e,c),c.length<1)return e;let r;for(let o of c){let d=N(o,t,n),g=se(t,n,d);if(d)if(g.length>0)r=d;else return d}return r},"findNonClusterChild"),z=u(e=>!a.has(e)||!a.get(e).externalConnections?e:a.has(e)?a.get(e).id:e,"getAnchorId"),W=u((e,t)=>{if(!e||t>10){s.debug("Opting out, no graph ");return}else s.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.warn("Cluster identified",n," Replacement id in edges: ",N(n,e,n)),X.set(n,V(n,e)),a.set(n,{id:N(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){let c=e.children(n),r=e.edges();c.length>0?(s.debug("Cluster identified",n,X),r.forEach(o=>{let d=D(o.v,n),g=D(o.w,n);d^g&&(s.warn("Edge: ",o," leaves cluster ",n),s.warn("Descendants of XXX ",n,": ",X.get(n)),a.get(n).externalConnections=!0)})):s.debug("Not a cluster ",n,X)});for(let n of a.keys()){let c=a.get(n).id,r=e.parent(c);r!==n&&a.has(r)&&!a.get(r).externalConnections&&(a.get(n).id=r)}e.edges().forEach(function(n){let c=e.edge(n);s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let r=n.v,o=n.w;if(s.warn("Fix XXX",a,"ids:",n.v,n.w,"Translating: ",a.get(n.v)," --- ",a.get(n.w)),a.get(n.v)||a.get(n.w)){if(s.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),r=z(n.v),o=z(n.w),e.removeEdge(n.v,n.w,n.name),r!==n.v){let d=e.parent(r);a.get(d).externalConnections=!0,c.fromCluster=n.v}if(o!==n.w){let d=e.parent(o);a.get(d).externalConnections=!0,c.toCluster=n.w}s.warn("Fix Replacing with XXX",r,o,n.name),e.setEdge(r,o,c,n.name)}}),s.warn("Adjusted Graph",m(e)),Z(e,0),s.trace(a)},"adjustClustersAndEdges"),Z=u((e,t)=>{if(s.warn("extractor - ",t,m(e),e.children("D")),t>10){s.error("Bailing out");return}let n=e.nodes(),c=!1;for(let r of n){let o=e.children(r);c=c||o.length>0}if(!c){s.debug("Done, no node has children",e.nodes());return}s.debug("Nodes = ",n,t);for(let r of n)if(s.debug("Extracting node",r,a,a.has(r)&&!a.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",t),!a.has(r))s.debug("Not a cluster",r,t);else if(!a.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){s.warn("Cluster without external connections, without a parent and with children",r,t);let d=e.graph().rankdir==="TB"?"LR":"TB";a.get(r)?.clusterData?.dir&&(d=a.get(r).clusterData.dir,s.warn("Fixing dir",a.get(r).clusterData.dir,d));let g=new S({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.warn("Old graph before copy",m(e)),U(r,e,g,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:a.get(r).clusterData,label:a.get(r).label,graph:g}),s.warn("New graph after copy node: (",r,")",m(g)),s.debug("Old graph after copy",m(e))}else s.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!a.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&&e.children(r).length>0,e.children("D"),t),s.debug(a);n=e.nodes(),s.warn("New list of nodes",n);for(let r of n){let o=e.node(r);s.warn(" Now next level",r,o),o?.clusterNode&&Z(o.graph,t+1)}},"extractor"),$=u((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(c=>{let r=e.children(c),o=$(e,r);n=[...n,...o]}),n},"sorter"),L=u(e=>$(e,e.children()),"sortNodesByHierarchy");var I=u(async(e,t,n,c,r,o)=>{s.warn("Graph in recursive render:XAX",m(t),r);let d=t.graph().rankdir;s.trace("Dir in recursive render - dir:",d);let g=e.insert("g").attr("class","root");t.nodes()?s.info("Recursive render XXX",t.nodes()):s.info("No nodes found for",t),t.edges().length>0&&s.info("Recursive edges",t.edge(t.edges()[0]));let l=g.insert("g").attr("class","clusters"),h=g.insert("g").attr("class","edgePaths"),p=g.insert("g").attr("class","edgeLabels"),b=g.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(f){let i=t.node(f);if(r!==void 0){let w=JSON.parse(JSON.stringify(r.clusterData));s.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,w.height,`
Parent cluster`,r.height),t.setNode(r.id,w),t.parent(f)||(s.trace("Setting parent",f,r.id),t.setParent(f,r.id,w))}if(s.info("(Insert) Node XXX"+f+": "+JSON.stringify(t.node(f))),i?.clusterNode){s.info("Cluster identified XBX",f,i.width,t.node(f));let{ranksep:w,nodesep:y}=t.graph();i.graph.setGraph({...i.graph.graph(),ranksep:w+25,nodesep:y});let E=await I(b,i.graph,n,c,t.node(f),o),C=E.elem;Y(i,C),i.diff=E.diff||0,s.info("New compound node after recursive render XAX",f,"width",i.width,"height",i.height),H(C,i)}else t.children(f).length>0?(s.trace("Cluster - the non recursive path XBX",f,i.id,i,i.width,"Graph:",t),s.trace(N(i.id,t)),a.set(i.id,{id:N(i.id,t),node:i})):(s.trace("Node - the non recursive path XAX",f,b,t.node(f),d),await j(b,t.node(f),d))})),await u(async()=>{let f=t.edges().map(async function(i){let w=t.edge(i.v,i.w,i.name);s.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),s.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),s.info("Fix",a,"ids:",i.v,i.w,"Translating: ",a.get(i.v),a.get(i.w)),await T(p,w)});await Promise.all(f)},"processEdges")(),s.info("Graph before layout:",JSON.stringify(m(t))),s.info("############################################# XXX"),s.info("###                Layout                 ### XXX"),s.info("############################################# XXX"),q(t),s.info("Graph after layout:",JSON.stringify(m(t)));let J=0,{subGraphTitleTotalMargin:x}=k(o);return await Promise.all(L(t).map(async function(f){let i=t.node(f);if(s.info("Position XBX => "+f+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i?.clusterNode)i.y+=x,s.info("A tainted cluster node XBX1",f,i.id,i.width,i.height,i.x,i.y,t.parent(f)),a.get(i.id).node=i,O(i);else if(t.children(f).length>0){s.info("A pure cluster node XBX1",f,i.id,i.x,i.y,i.width,i.height,t.parent(f)),i.height+=x,t.node(i.parentId);let w=i?.padding/2||0,y=i?.labelBBox?.height||0,E=y-w||0;s.debug("OffsetY",E,"labelHeight",y,"halfPadding",w),await B(l,i),a.get(i.id).node=i}else{let w=t.node(i.parentId);i.y+=x/2,s.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",w,w?.offsetY,i),O(i)}})),t.edges().forEach(function(f){let i=t.edge(f);s.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(i),i),i.points.forEach(C=>C.y+=x/2);let w=t.node(f.v);var y=t.node(f.w);let E=M(h,i,a,n,w,y,c);R(i,E)}),t.nodes().forEach(function(f){let i=t.node(f);s.info(f,i.type,i.diff),i.isGroup&&(J=i.diff)}),s.warn("Returning from recursive render XAX",g,J),{elem:g,diff:J}},"recursiveRender"),pe=u(async(e,t)=>{let n=new S({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),c=t.select("g");F(c,e.markers,e.type,e.diagramId),_(),G(),A(),Q(),e.nodes.forEach(o=>{n.setNode(o.id,{...o}),o.parentId&&n.setParent(o.id,o.parentId)}),s.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){let d=o.start,g=d+"---"+d+"---1",l=d+"---"+d+"---2",h=n.node(d);n.setNode(g,{domId:g,id:g,parentId:h.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(g,h.parentId),n.setNode(l,{domId:l,id:l,parentId:h.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(l,h.parentId);let p=structuredClone(o),b=structuredClone(o),v=structuredClone(o);p.label="",p.arrowTypeEnd="none",p.id=d+"-cyclic-special-1",b.arrowTypeEnd="none",b.id=d+"-cyclic-special-mid",v.label="",h.isGroup&&(p.fromCluster=d,v.toCluster=d),v.id=d+"-cyclic-special-2",n.setEdge(d,g,p,d+"-cyclic-special-0"),n.setEdge(g,l,b,d+"-cyclic-special-1"),n.setEdge(l,d,v,d+"-cyc<lic-special-2")}else n.setEdge(o.start,o.end,{...o},o.id)}),s.warn("Graph at first:",JSON.stringify(m(n))),W(n),s.warn("Graph after XAX:",JSON.stringify(m(n)));let r=P();await I(c,n,e.type,e.diagramId,void 0,r)},"render");export{pe as render};
